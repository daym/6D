#ifndef __6D_VALUES_H
#define __6D_VALUES_H
#include <stdio.h>
#include <stdlib.h>
#ifdef __cplusplus
#define NODET Values::NodeT
#define BEGIN_NAMESPACE_6D(name) namespace name {
#define END_NAMESPACE_6D(name) }
#define USE_NAMESPACE_6D(name) using namespace name;
#define BEGIN_STRUCT_6D(name) struct name : Values::Node {
#define END_STRUCT_6D(name) };
#define NATIVEUINT FFIs::NativeUInt
#define NATIVEFLOAT FFIs::NativeFloat
#define NATIVEINT FFIs::NativeInt
#else
#define NODET NodeT
#define MNODET NodeT
//struct Node*
#define NATIVEUINT NativeUInt
#define NATIVEFLOAT NativeFloat
#define NATIVEINT NativeInt
typedef int bool;
#define true 1
#define false 0
#define BEGIN_NAMESPACE_6D(name) 
#define END_NAMESPACE_6D(name) 
#define USE_NAMESPACE_6D(name)
#define BEGIN_STRUCT_6D(name) struct name { \
	struct Node super;
#define END_STRUCT_6D(name) };
#endif
#ifdef __GNUC__
#define G_5D_PURE __attribute__ ((pure))
#define LIKELY_6D(x) __builtin_expect(!!(x), 1)
#define UNLIKELY_6D(x) __builtin_expect(!!(x), 0)
#else
#define G_5D_PURE
#define LIKELY_6D(x) x
#define UNLIKELY_6D(x) x
#endif
BEGIN_NAMESPACE_6D(Values)

/* this is used as the "result" of the parser (one of it is the result) */
typedef const struct Node* NodeT;
/* given a string, returns a node that can be quickly checked for identicalness */
NodeT symbolFromStr(const char* name) G_5D_PURE;

/* given two nodes, constructs a "Cons" with a head and tail and return it */
NodeT cons(NodeT head, NodeT tail) G_5D_PURE;

/* given a string, somehow puts it into something resembling a NodeT */
NodeT strC(const char* value) G_5D_PURE;

/* given a Str, returns its size */
size_t getStrSize(NodeT n) G_5D_PURE;

/* given a string, returns a node that can be quickly checked for identicalness (and is not a symbol). */
NodeT keywordFromStr(const char* name) G_5D_PURE;

/* given a formal parameter and a body, returns a node that represents a function with that formal parameter and body */
NodeT fn(NodeT formalParameter, NodeT body) G_5D_PURE;

/* given a callable and argument, returns a node that represents a Call */
NodeT call(NodeT callable, NodeT argument) G_5D_PURE;

/* shorthand for call(call */
static inline NodeT call2(NodeT callable, NodeT argument, NodeT argument2) {
	return call(call(callable, argument), argument2);
}

/* given a symbol, returns its text. If not a symbol, returns NULL */
const char* getSymbol1Name(NodeT node) G_5D_PURE;

/* given a keyword, returns its text. If not a keyword, returns NULL */
const char* getKeyword1Name(NodeT node) G_5D_PURE;

/* given a Cons, returns its head */
NodeT getConsHead(NodeT) G_5D_PURE;

/* given a Cons, returns its tail. Tail is USUALLY nil or a(nother) Cons */
NodeT getConsTail(NodeT) G_5D_PURE;

/* given a Call, returns its callable. */
NodeT getCallCallable(NodeT) G_5D_PURE;

/* given a Call, returns its argument. */
NodeT getCallArgument(NodeT) G_5D_PURE;

/* given a Fn, returns its formal parameter. */
NodeT getFnParameter(NodeT) G_5D_PURE;

/* given a Fn, returns its body. */
NodeT getFnBody(NodeT) G_5D_PURE;

/* finds out whether node is a Symbol */
bool symbolP(NodeT node) G_5D_PURE;

/* finds out whether node is a Keyword */
bool keywordP(NodeT node) G_5D_PURE;

bool fnP(NodeT) G_5D_PURE;
bool callP(NodeT) G_5D_PURE;
bool consP(NodeT) G_5D_PURE;
bool nilP(NodeT) G_5D_PURE;
bool boxP(NodeT) G_5D_PURE;
bool strP(NodeT) G_5D_PURE; /* not necessarily disjunct from int */
bool intP(NodeT) G_5D_PURE;
bool integerP(NodeT) G_5D_PURE;
bool floatP(NodeT) G_5D_PURE;
void* getBoxValue(NodeT node) G_5D_PURE;
char* getStrValue(NodeT node) G_5D_PURE;
NodeT operation(NodeT callable, NodeT argument1, NodeT argument2) G_5D_PURE;
NodeT getOperationArgument1(NodeT o) G_5D_PURE;
NodeT getOperationArgument2(NodeT o) G_5D_PURE;
NodeT getOperationOperator(NodeT o) G_5D_PURE;
bool operationP(NodeT o) G_5D_PURE;
/*extern NodeT nil;*/
#define nil NULL

void str(NodeT, FILE*);

NodeT pair(NodeT a, NodeT b) G_5D_PURE;
NodeT getPairFst(NodeT p) G_5D_PURE;
NodeT getPairSnd(NodeT p) G_5D_PURE;

static inline NodeT close(NodeT /* symbol */ parameter, NodeT argument, NodeT body) {
	return call(fn(parameter, body), argument);
}
int getSymbolreferenceIndex(NodeT n) G_5D_PURE;
NodeT symbolreference(int index) G_5D_PURE;

typedef NodeT (*FFIFnCallbackT)(NodeT, NodeT data);
NodeT FFIFn(FFIFnCallbackT callback, NodeT aData, const char* name) G_5D_PURE;
NodeT FFIFnNoGC(FFIFnCallbackT callback, NodeT aData, const char* name) G_5D_PURE;
bool FFIFnP(NodeT node) G_5D_PURE;
NodeT execFFIFn(NodeT node, NodeT argument) /*impure*/;
bool FFIFnWithCallbackP(NodeT n, FFIFnCallbackT callback) G_5D_PURE; /* used "internally" only */

bool ratioP(NodeT n) G_5D_PURE;
NodeT getRatioA(NodeT n) G_5D_PURE;
NodeT getRatioB(NodeT n) G_5D_PURE;

/* errors */

NodeT parseError(NodeT aExpectedInput, NodeT aGotInput) G_5D_PURE;
NodeT evalError(NodeT aExpectedInput, NodeT aGotInput, NodeT aContext) G_5D_PURE;
bool errorP(NodeT n) G_5D_PURE;
NodeT getErrorKind(NodeT node) G_5D_PURE;
NodeT getErrorExpectedInput(NodeT node) G_5D_PURE;
NodeT getErrorGotInput(NodeT node) G_5D_PURE;
NodeT getErrorContext(NodeT node) G_5D_PURE;

void initIntegers(void);
void initFloats(void);
END_NAMESPACE_6D(Values)
#endif /* ndef __6D_VALUES_H */
