#ifndef __5D_FFI
#define __5D_FFI
#include "6D/Values"

namespace FFIs {
/* conversions */
static inline Values::NodeT internNative(Values::NodeT value) {
	return value;
}
Values::NodeT internNative(bool value) G_5D_PURE;

#ifdef __SIZEOF_LONG__
#if __SIZEOF_LONG_LONG__ != __SIZEOF_LONG__
#define INTERN_NATIVE_NEED_LONG_LONG
Values::NodeT internNative(long long value);
Values::NodeT internNativeU(unsigned long long value);
typedef long int NativeInt; /* register type */
#else
typedef long long int NativeInt; /* register type */
#endif
#else
#define INTERN_NATIVE_NEED_LONG_LONG
typedef int NativeInt; /* register type */
Values::NodeT internNative(long long value);
Values::NodeT internNativeU(unsigned long long value);
#endif
#ifdef __SIZEOF_LONG__
#if __SIZEOF_LONG_LONG__ != __SIZEOF_LONG__
typedef unsigned long int NativeUInt; /* register type */
#else
typedef unsigned long long int NativeUInt; /* register type */
#endif
#else
typedef unsigned int NativeUInt; /* register type */
#endif

#if defined(__VFP_FP__) || defined(__ARM_EABI__)
/* ARM doesn't have extended-precision floating point */
typedef double NativeFloat;
//#define NATIVEFLOAT_PRECISION 15
#else
typedef long double NativeFloat;
//#define NATIVEFLOAT_PRECISION 19
#endif
#ifdef WIN32
typedef unsigned int uint32_t; /* why me... */
#endif

Values::NodeT internNative(NativeInt value);
Values::NodeT internNativeU(NativeUInt value);
Values::NodeT internNative(NativeFloat value);

int intFromNode(Values::NodeT root);
int nearestIntFromNode(Values::NodeT root);
long longFromNode(Values::NodeT root);
long long longLongFromNode(Values::NodeT root);
short shortFromNode(Values::NodeT root);
void* pointerFromNode(const Values::NodeT root);
bool booleanFromNode(Values::NodeT root); /* evaluates! */
char* stringFromNode(Values::NodeT root);
char* stringOrNilFromNode(Values::NodeT root);
size_t stringSizeFromNode(Values::NodeT root);
float floatFromNode(Values::NodeT root);
long double longDoubleFromNode(Values::NodeT root);
double doubleFromNode(Values::NodeT root);
long long sizedIntFromNode(int bitCount, Values::NodeT root);
/* this will eventually be used to force the entire lazy cons (one level) to be evaluated. Use with care (infinite lists aren't gonna like that). */
static inline Values::NodeT consFromNode(Values::NodeT root) {
	return(root);
}
static inline Values::NodeT pairFromNode(Values::NodeT root) {
	return(root);
}
static inline Values::NodeT nodeFromNode(Values::NodeT root) {
	return root;
}

};
#endif
