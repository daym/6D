#ifndef __VALUES_H
#define __VALUES_H
#include "6D/Values"
#include "Allocators/Allocators"

BEGIN_NAMESPACE_6D(Values)
USE_NAMESPACE_6D(Allocators)
/* it doesn't matter to me what exactly Node is, I'm just using struct here so it shuts up */

struct Node GC_BASECLASS {
	virtual ~Node(void);
	virtual void str(FILE* destination) const;
};
#define OVERRIDE_STR_6D virtual void str(FILE* destination) const;

/* semi-private */
enum {
	TAG_SYMBOLREFERENCE /* very VERY often used */,
	TAG_INT,
	TAG_FFI_FN /* quite important */,
	TAG_FLOAT,
	TAG_INTEGER,
	TAG_RATIO,
	TAG_CONS,
	TAG_CALL,
	TAG_FN,
	TAG_BOX,
	TAG_STR,
	/* convenience */
	TAG_KEYWORD,
	TAG_SYMBOL,
	TAG_ERROR,
	TAG_OPAQUE,
};
int tagOfNode(NodeT node);

struct Call : Node {
	NodeT callable;
	NodeT argument;
	NodeT result;
	int resultGeneration;
	Call(NodeT aCallable, NodeT aArgument) :
		callable(aCallable),
		argument(aArgument)
	{
		this->callable = callable;
		this->argument = argument;
		this->result = NULL;
		this->resultGeneration = -1;
	}
	virtual ~Call() {
	}
};
static inline int indexOfSymbol(NodeT needle, int startingIndex, NodeT boundNames) {
	if(boundNames == nil)
		return(-1);
	else if(getConsHead(boundNames) == needle)
		return(startingIndex);
	else
		return(indexOfSymbol(needle, startingIndex + 1, getConsTail(boundNames)));
}
void setCallResult(NodeT call, NodeT result);
static inline const void* getCXXInstance(NodeT n) {
	return n;
}
void increaseGeneration(void);
int getGeneration(void) G_5D_PURE;

END_NAMESPACE_6D(Values)
#endif /* ndef __VALUES_H */
