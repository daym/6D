#ifndef __VALUES_H
#define __VALUES_H
#include "6D/Values"
#include "Allocators/Allocators"

BEGIN_NAMESPACE_6D(Values)
USE_NAMESPACE_6D(Allocators)
/* it doesn't matter to me what exactly Node is, I'm just using struct here so it shuts up */

struct Node GC_BASECLASS {
	int tag;
};
#define OVERRIDE_STR_6D virtual void str(FILE* destination) const;

/* semi-private */
enum {
	TAG_Nil = 0,
	TAG_Symbolreference = 1 /* very VERY often used */,
	TAG_CFFIFn = 2/* quite important */,
	/* numbers are in promotion order */
	TAG_Int = 3,
	TAG_Integer = 4,
	TAG_Ratio = 6,
	TAG_Float = 5,
	TAG_Cons = 7,
	TAG_Call = 8,
	TAG_Fn = 9,
	TAG_Box = 10,
	TAG_Str = 11,
	/* convenience */
	TAG_Keyword,
	TAG_Symbol,
	TAG_Error,
	TAG_Opaque,
	TAG_Hashtable,
};
static inline struct Node* Node_initTag(struct Node* node, int tag) {
	node->tag = tag;
	return node;
}
int tagOfNode(NodeT node);

BEGIN_STRUCT_6D(Call)
	NodeT callable;
	NodeT argument;
	NodeT result;
	int resultGeneration;
END_STRUCT_6D(Call)
static inline int indexOfSymbol(NodeT needle, int startingIndex, NodeT boundNames) {
	if(boundNames == nil)
		return(-1);
	else if(getConsHead(boundNames) == needle)
		return(startingIndex);
	else
		return(indexOfSymbol(needle, startingIndex + 1, getConsTail(boundNames)));
}
void setCallResult(NodeT call, NodeT result);
static inline const void* getCXXInstance(NodeT n) {
	return n;
}
void increaseGeneration(void);
int getGeneration(void) G_5D_PURE;

END_NAMESPACE_6D(Values)
#endif /* ndef __VALUES_H */
