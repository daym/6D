#ifndef __SCANNERS_SCANNER_H
#define __SCANNERS_SCANNER_H
#include <stdio.h>
#include <assert.h>
#include <string>
#include <vector>
#include <stack>
#include "Values/Values"

#define GETC fgetc(this->file)
#define UNGETC(c) ungetc(c, this->file)
template<typename T>
class Scanner {
private: /* ugh */
	Values::NodeT value;
	FILE* file;
	std::string name;
	int linenumber;
	bool bBeginningOfLine;
	T env;
	std::stack<int> indents;
	int indent; /* of current line */
	Values::NodeT SEOF;
	bool bEOF;
protected:
	/** \return whether we already injected a token or not. */
	bool skipWhitespace(void) {
		int c;
		if(!bEOF)
		while((c = GETC) != EOF && c != 26/*EOF*/) {
			if(c == ' ' || c == '\t') {
				if(this->bBeginningOfLine)
					this->indent += 1;
			} else if(c == '\r') {
			} else if(c == '\n') {
				this->bBeginningOfLine = true;
				this->indent = 0;
				this->value = env.SLF;
				++this->linenumber;
				return true;
			} else if(this->bBeginningOfLine) { /* actual text for the first time on the line */
				UNGETC(c); /* make sure the user will see the actual text */
				this->bBeginningOfLine = false;
				if(this->indent > this->indents.top()) {
					this->indents.push(this->indent);
					this->value = env.Sindent;
					return true;
				} else if(this->indent < this->indents.top()) {
					int diff;
					this->value = env.Sdedent;
					this->indents.pop(); /* decrease indentation by ONE level */
					assert(!this->indents.empty()); /* 0 will never be removed */
					diff = (this->indents.top() - this->indent);
					if(diff < 0) { /* this indentation does not exist - it would have been in-between */
						this->value = env.error("<known-indentation>", "<unknown-indentation>");
						return true;
					} else if(diff > 0) { /* there are others to be closed (will be done at the next iteration). */
						this->bBeginningOfLine = true; /* make sure to check at the next iteration, too */
						return true;
					} else { /* this one is the right one */
						return true;
					}
				}
				return false;
			} else {
				UNGETC(c); /* make sure the user will see the actual text */
				return false;
			}
		}
		bEOF = true;
		return false;
	}
public:
	Scanner(T aEnv) : 
		value(nil),
		name(""),
		linenumber(1),
	        bBeginningOfLine(true),
		env(aEnv),
		indent(0) {
		this->indents.push(indent);
		SEOF = env.SEOF;
		bEOF = false;
	}
	void push(FILE* file, int linenumber, const char* name) {
		/* TODO support "include" files? */
		this->file = file;
		this->linenumber = linenumber;
		this->name = name;
	}
	void pop(void) {
	}
	Values::NodeT consume(void) {
		Values::NodeT previousValue = this->value;
		if(!this->skipWhitespace()) {
			if(bEOF) { /* TODO unlikely */
				if(this->indents.size() > 1) {
					//fprintf(stderr, "faking dedent\n");
					this->indents.pop();
					this->value = env.Sdedent;
				} else
					this->value = SEOF;
			} else {
				/* one of the less nice things is that this will not report back that it found EOF so we will try to read again. */
				this->value = env.readToken(this->file, /*ref*/this->linenumber);
			}
		}
		return previousValue;
	}
	/*Values::NodeT consume1(Values::NodeT expectedToken) {
		using namespace Values;
		if(this->value != expectedToken)
			return env.error(getSymbol1Name(expectedToken), getSymbol1Name(this->value));
		else
			return consume(expectedToken);
	}*/
	Values::NodeT getToken(void) const {
		return this->value;
	}
	int getLinenumber(void) const {
		return this->linenumber;
	}
};
#endif /* ndef __SCANNERS_SCANNER_H */
