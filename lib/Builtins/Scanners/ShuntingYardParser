#ifndef __SCANNERS_SHUNTING_YARD_PARSER_H
#define __SCANNERS_SHUNTING_YARD_PARSER_H
#include <stack>
#include <assert.h>
#include <vector>
#include "Values/Values"
namespace Scanners {
using namespace Values;
/* poor man's closure: */
template<typename S, typename T>
struct Parser GC_BASECLASS {
private:
	std::vector<NodeT ALLOCATOR_VECTOR> result;
	std::stack<NodeT ALLOCATOR_STACK> operators;
	S& tokenizer;
	T& env;
	int executionResultCount;
	int argcount;
	Values::NodeT prevInput;
	bool unaryP(Values::NodeT input) {
		int argcount = env.operatorArgcount(input);
		if (argcount > 1) {
			Values::NodeT neutral = env.operatorPrefixNeutral(input);
			return !env.errorP(neutral);
		} else
			return (argcount == 1 || argcount == -1);
	}
	Values::NodeT applyAndPush(int argcount, bool bUnary, Values::NodeT input) {
		/* Note: there is no case for binary suffix operators abused as unary operator. */
		bool bClosingParen = env.closingParenP(input);
		NodeT pendingOperator;
		while (!operators.empty() && (pendingOperator = operators.top(), (!env.openingParenP(pendingOperator) && (!bUnary || unaryP(pendingOperator))))) { // keep in sync with below.
			if (env.operatorLE(input, pendingOperator)) {
				executionResultCount += env.callRpnOperator(pendingOperator, result);
				operators.pop();
			} else
				break;
		}
		if (bClosingParen) {
			if ((!operators.empty() && operators.top() == env.openingParenOf(input)))
				operators.pop();
			else {
				input = /*yield */ env.error(getSymbol1Name(env.openingParenOf(input)), (!operators.empty()) ? (getSymbol1Name(operators.top())) : ("<value>"));
				return input;
			}
		} else if(argcount == -1) { /* suffix */
			env.callRpnOperator(input, result);
			input = prevInput; /* make sure we don't see the suffix operator there on its own (since it was already applied) */
		} else 
			operators.push(input);
		if (env.macroStarterP(input)) { /* assumes macros all start at prefix loc */
			result.push_back( /*yield */ env.startMacro(input, tokenizer));
			//input = nil; /* for the purposes of operator detection, the value was not an operator. Note that we cannot write result.back() or similar here since otherwise macro standins could be misdetected. */
			++executionResultCount;
		}
		return input;
	}
	inline void pushOperand(Values::NodeT input) {
		result.push_back(input); 
		++executionResultCount;
	}
public:
	Parser(S& aTokenizer, T& aEnv) : 
		tokenizer(aTokenizer),
		env(aEnv)
	{
	}
	std::vector<NodeT ALLOCATOR_VECTOR> parse(Values::NodeT endToken) {
		//"\n\tThis works like the following:\n\t\t#operators is a stack of operators. It is always kept in order of ascending precedence. \n\t\t(non-operator) values are just emitted.\n\t\tAn opening parenthesis would just be put on the operator stack (without popping anything off), EVEN THOUGH it is recorded with the lowest precedence ever.\n\t\tAn operator is handled like this: if we try to push a new operator with lower precedence on top, it will keep popping (and emitting) existing operators off the operator stack until the invariant is satisfied. Then the operator is pushed on the operator stack.\n\t\tA closing parenthesis is an " operator     " which is not being put on the operator stack (it would do nothing anyway), otherwise handled like any other operator.\n\t";
		using namespace Values;
		Values::NodeT input;
		prevInput = env.SopeningParen; // intern("(");
		NodeT SEOF = env.SEOF;
		while((input = tokenizer.getToken()), !env.errorP(input) && input != SEOF && (input != endToken || !operators.empty()) ) {
			tokenizer.consume();
			if (env.openingParenP(input)) { /* special case of the stuff below in order to declutter the stuff below */
				operators.push(input);
				if (env.macroStarterP(input)) {
					pushOperand(/*yield */ env.startMacro(input, tokenizer)); /* this is the final result for the macro, probably */
					input = nil; /* for the purposes of operator detection, the value was not an operator. Note that we cannot write result.back() or similar here since otherwise macro standins could be misdetected. */
				}
			} else if(prevInput == env.Sleftparen && tokenizer.getToken() == env.Srightparen && env.operatorP(input)) { /* (+) */
				pushOperand(input);
				applyAndPush(0, false, tokenizer.consume());
				if(env.errorP(input))
					return result;
				input = nil; // not an operator and not first a ) and then a prefix operator
			} else if(env.operatorP(input)) {
				bool bUnary = false;
				argcount = env.operatorArgcount(input);
				if(argcount == 1 && (!env.operatorP(prevInput) || env.closingParenP(prevInput))) { /* implicit application before unary operator */
					prevInput = applyAndPush(2, false, env.Sapply);
					if(env.errorP(prevInput))
						return result;
				}
				if (env.operatorP(prevInput) && (!env.closingParenP(prevInput) || unaryP(input)) && !env.closingParenP(input)) { /* either prefix operator or binary operator that has been abused as an unary operator (f.e. -3). Parens are not unary. */
					bUnary = true;
					if (argcount > 1) { /* binary operator has been abused as an unary operator */
						Values::NodeT neutral = env.operatorPrefixNeutral(input);
						pushOperand(/* yield */ neutral);
						if (env.errorP(neutral)) { /* binary operator is not allowed to be abused as an unary operator */
							return result;
						}
					}
				} else if (argcount == -1) { /* unary suffix operator */
					bUnary = true;
				}
				input = applyAndPush(argcount, bUnary, input);
				if(env.errorP(input))
					return result;
			} else { /* current token not an operator: might be either a value or a function call argument. In both cases it will be food for some pending operator. */
				if (!env.operatorP(prevInput) || env.closingParenP(prevInput)) { /* function call */
					prevInput = applyAndPush(2, false, env.Sapply);
					if(env.errorP(prevInput))
						return result;
				}
				pushOperand(/*yield */ input);
			}
			prevInput = input; // (!env.closingParenP(input)) ? (input) : nil;
		}
		while (!operators.empty()) {
			executionResultCount += env.callRpnOperator(operators.top(), result);
			operators.pop();
		}
		return result;
	}
};
template<typename S, typename T>
static inline std::vector<NodeT ALLOCATOR_VECTOR> parse(S& tokenizer, T& env, Values::NodeT endToken) {
	return Parser<S,T>(tokenizer, env).parse(endToken);
}
} /* end namespace Scanners */

#endif /* ndef __SCANNERS_SHUNTING_YARD_PARSER_H */
