#ifndef __SCANNERS_SHUNTING_YARD_PARSER_H
#define __SCANNERS_SHUNTING_YARD_PARSER_H
#include <stack>
#include <assert.h>
#include <vector>
#include "Values/Values"
namespace Scanners {
using namespace Values;
template<typename T>
static bool unaryP(const T& env, Values::NodeT input) {
	int argcount = env.operatorArgcount(input);
	if (argcount > 1) {
		Values::NodeT neutral = env.operatorPrefixNeutral(input);
		return !env.errorP(neutral);
	} else
		return (argcount == 1 || argcount == -1);
}
template<typename S, typename T>
static Values::NodeT applyAndPush(S& tokenizer, T& env, std::vector<NodeT ALLOCATOR_VECTOR>& result, std::stack<NodeT ALLOCATOR_STACK>& operators, int argcount, bool bUnary, Values::NodeT prevInput, Values::NodeT input) {
	/* Note: there is no case for binary suffix operators abused as unary operator. */
	bool bClosingParen = env.closingParenP(input);
	// !openingParenP(o) && (!bUnary || unaryP(env, o))
	NodeT pendingOperator;
	while (!operators.empty() && (pendingOperator = operators.top(), (!env.openingParenP(pendingOperator) && (!bUnary || unaryP(env, pendingOperator))))) { // keep in sync with below.
		if (env.operatorLE(input, pendingOperator)) {
			env.callRpnOperator(pendingOperator, result);
			operators.pop();
		} else
			break;
	}
	if (bClosingParen) {
		if ((!operators.empty() && operators.top() == env.openingParenOf(input)))
			operators.pop();
		else {
			input = /*yield */ env.error(getSymbol1Name(env.openingParenOf(input)), (!operators.empty()) ? (getSymbol1Name(operators.top())) : ("<value>"));
			return input;
		}
	} else if(argcount == -1) { /* suffix */
		env.callRpnOperator(input, result);
		input = prevInput; /* make sure we don't see the suffix operator there on its own (since it was already applied) */
	} else 
		operators.push(input);
	if (env.macroStarterP(input)) { /* assumes macros all start at prefix loc */
		result.push_back( /*yield */ env.startMacro(input, tokenizer));
		//input = nil; /* for the purposes of operator detection, the value was not an operator. Note that we cannot write result.back() or similar here since otherwise macro standins could be misdetected. */
	}
	return input;
}
template<typename S, typename T>
static std::vector<NodeT ALLOCATOR_VECTOR> parse(S& tokenizer, T& env, Values::NodeT endToken) {
	//"\n\tThis works like the following:\n\t\t#operators is a stack of operators. It is always kept in order of ascending precedence. \n\t\t(non-operator) values are just emitted.\n\t\tAn opening parenthesis would just be put on the operator stack (without popping anything off), EVEN THOUGH it is recorded with the lowest precedence ever.\n\t\tAn operator is handled like this: if we try to push a new operator with lower precedence on top, it will keep popping (and emitting) existing operators off the operator stack until the invariant is satisfied. Then the operator is pushed on the operator stack.\n\t\tA closing parenthesis is an " operator     " which is not being put on the operator stack (it would do nothing anyway), otherwise handled like any other operator.\n\t";
	using namespace Values;
	int argcount = 0;
	Values::NodeT input;
	NodeT prevInput = env.SopeningParen; // intern("(");
	std::vector<NodeT ALLOCATOR_VECTOR> result;
	std::stack<NodeT ALLOCATOR_STACK> operators; /* of Symbols */
	NodeT SEOF = env.SEOF;
	while((input = tokenizer.getToken()), !env.errorP(input) && input != SEOF && (input != endToken || !operators.empty()) ) {
		tokenizer.consume();
		if (env.openingParenP(input)) { /* special case of the stuff below in order to declutter the stuff below */
			operators.push(input);
			if (env.macroStarterP(input)) {
				result.push_back( /*yield */ env.startMacro(input, tokenizer)); /* this is the final result for the macro, probably */
				input = nil; /* for the purposes of operator detection, the value was not an operator. Note that we cannot write result.back() or similar here since otherwise macro standins could be misdetected. */
			}
		} else if(prevInput == env.Sleftparen && tokenizer.getToken() == env.Srightparen && env.operatorP(input)) { /* (+) */
			/* TODO don't match just "+)" at the beginning of a line? */
			result.push_back(input);
		} else if(env.operatorP(input)) {
			bool bUnary = false;
			argcount = env.operatorArgcount(input);
			if (env.operatorP(prevInput) && (!env.closingParenP(prevInput) || unaryP(env, input)) && !env.closingParenP(input)) { /* either prefix operator or binary operator that has been abused as an unary operator (f.e. -3). Parens are not unary. */
				bUnary = true;
				if(env.closingParenP(prevInput)) { /* implicit application */
					prevInput = applyAndPush(tokenizer, env, result, operators, 2, false, prevInput, env.Sapply);
					if(env.errorP(prevInput))
						return result;
				}
				if (argcount > 1) { /* binary operator has been abused as an unary operator */
					Values::NodeT neutral = env.operatorPrefixNeutral(input);
					result.push_back( /*yield */ neutral);
					if (env.errorP(neutral)) { /* binary operator is not allowed to be abused as an unary operator */
						return result;
					}
				}
			} else if (argcount == -1) { /* unary suffix operator */
				bUnary = true;
			}
			input = applyAndPush(tokenizer, env, result, operators, argcount, bUnary, prevInput, input);
			if(env.errorP(input))
				return result;
		} else { /* current token not an operator: might be either a value or a function call argument */
			if (!env.operatorP(prevInput) || env.closingParenP(prevInput)) { /* function call */
				prevInput = applyAndPush(tokenizer, env, result, operators, 2, false, prevInput, env.Sapply);
				if(env.errorP(prevInput))
					return result;
			}
			result.push_back( /*yield */ input);
		}
		prevInput = input; // (!env.closingParenP(input)) ? (input) : nil;
	}
	while (!operators.empty()) {
		env.callRpnOperator(operators.top(), result);
		operators.pop();
	}
	return result;
}
} /* end namespace Scanners */

#endif /* ndef __SCANNERS_SHUNTING_YARD_PARSER_H */
