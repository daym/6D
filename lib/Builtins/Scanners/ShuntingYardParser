#ifndef __SCANNERS_SHUNTING_YARD_PARSER_H
#define __SCANNERS_SHUNTING_YARD_PARSER_H
#include <stack>
#include <vector>
#include "Values/Values"
namespace Scanners {
using namespace Values;
template<typename T>
static bool unaryP(const T& env, Values::NodeT input) {
	int argcount = env.operatorArgcount(input);
	if (argcount > 1) {
		Values::NodeT neutral = env.operatorPrefixNeutral(input);
		return !env.errorP(neutral);
	} else
		return (argcount == 1 || argcount == -1);
}
template<typename S, typename T>
static std::vector<NodeT ALLOCATOR_VECTOR> parse(S tokenizer, T env) {
	//"\n\tThis works like the following:\n\t\t#operators is a stack of operators. It is always kept in order of ascending precedence. \n\t\t(non-operator) values are just emitted.\n\t\tAn opening parenthesis would just be put on the operator stack (without popping anything off), EVEN THOUGH it is recorded with the lowest precedence ever.\n\t\tAn operator is handled like this: if we try to push a new operator with lower precedence on top, it will keep popping (and emitting) existing operators off the operator stack until the invariant is satisfied. Then the operator is pushed on the operator stack.\n\t\tA closing parenthesis is an " operator     " which is not being put on the operator stack (it would do nothing anyway), otherwise handled like any other operator.\n\t";
	using namespace Values;
	int argcount = 0;
	Values::NodeT input;
	NodeT prevInput = env.SopeningParen; // intern("(");
	std::vector<NodeT ALLOCATOR_VECTOR> result;
	std::stack<NodeT ALLOCATOR_STACK> operators; /* of Symbols */
	NodeT SEOF = env.SEOF;
	while((input = tokenizer.getToken()), !env.errorP(input) && input != SEOF) {
		tokenizer.consume();
		if (env.openingParenP(input))
			operators.push(input);
		else {
			if (env.operatorP(input)) {
				bool bUnary = false;
				argcount = env.operatorArgcount(input);
				if (env.operatorP(prevInput)) {
					bUnary = true;
					if (argcount > 1) {
						Values::NodeT neutral = env.operatorPrefixNeutral(input);
						result.push_back( /*yield */ neutral);
						if (env.errorP(neutral))
							return result;
					};
				} else if (argcount == -1)
					bUnary = true;
				if (env.macroStarterP(input))
					result.push_back( /*yield */ input);
				bool bClosingParen = env.closingParenP(input);
				// !openingParenP(o) && (!bUnary || unaryP(env, o))
				NodeT pendingOperator;
				while (!operators.empty() && (pendingOperator = operators.top(), (!env.openingParenP(pendingOperator) && (!bUnary || unaryP(env, pendingOperator))))) { // keep in sync with below.
					//pendingOperator = operators.top();
					if (env.operatorLE(input, pendingOperator)) {
						env.callRpnOperator(operators.top(), result);
						operators.pop();
					} else
						break;
				}
				if (bClosingParen) {
					if ((!operators.empty() && operators.top() == env.openingParenOf(input)))
						operators.pop();
					else {
						result.push_back( /*yield */ env.error(getSymbol1Name(env.openingParenOf(input)), (!operators.empty()) ? (getSymbol1Name(operators.top())) : ("<value>")));
						return result;
					}
				} else
					operators.push(input);
				argcount = env.operatorArgcount(input);
			} else {
				if (env.operatorP(prevInput)) // && !env.openingParenP(prevInput))
					result.push_back( /*yield */ input);
				else { // call, keep in sync with above.
					NodeT o = input;
					result.push_back( /*yield */ input);
					input = env.Sapply; // intern(" ");
					while (!operators.empty() /* always inside for binary */) {
						Values::NodeT pendingOperator = operators.top();
						if (env.operatorLE(input, pendingOperator)) {
							env.callRpnOperator(operators.top(), result);
							operators.pop();
						} else
							break;
					}
					operators.push(input);
					argcount = env.operatorArgcount(input);
					input = o;
				}
			}
		}
		prevInput = (!env.closingParenP(input)) ? (input) : nil;
	}
	while (!operators.empty()) {
		env.callRpnOperator(operators.top(), result);
		operators.pop();
	}
	return result;
}
} /* end namespace Scanners */

#endif /* ndef __SCANNERS_SHUNTING_YARD_PARSER_H */
